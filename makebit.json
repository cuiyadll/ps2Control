{"README.md":"# makerobot\n这个库是Robot micro:bit 扩展板使用！\n","main.ts":"/*\r\n湖南创乐博智能科技有限公司\r\n编辑：朱林\r\n日期：2020年1月11日\r\n*/\r\n\r\n\r\n//% color=\"#31C7D5\" weight=10 icon=\"\\uf1d1\"\r\nnamespace makerobo {\r\n    const PCA9685_ADDRESS = 0x40\r\n    const MODE1 = 0x00\r\n    const MODE2 = 0x01\r\n    const SUBADR1 = 0x02\r\n    const SUBADR2 = 0x03\r\n    const SUBADR3 = 0x04\r\n    const PRESCALE = 0xFE\r\n    const LED0_ON_L = 0x06\r\n    const LED0_ON_H = 0x07\r\n    const LED0_OFF_L = 0x08\r\n    const LED0_OFF_H = 0x09\r\n    const ALL_LED_ON_L = 0xFA\r\n    const ALL_LED_ON_H = 0xFB\r\n    const ALL_LED_OFF_L = 0xFC\r\n    const ALL_LED_OFF_H = 0xFD\r\n\r\n    const STP_CHA_L = 2047\r\n    const STP_CHA_H = 4095\r\n\r\n    const STP_CHB_L = 1\r\n    const STP_CHB_H = 2047\r\n\r\n    const STP_CHC_L = 1023\r\n    const STP_CHC_H = 3071\r\n\r\n    const STP_CHD_L = 3071\r\n    const STP_CHD_H = 1023\r\n\r\n    export enum Servos {\r\n        S1 = 0x01,\r\n        S2 = 0x02,\r\n        S3 = 0x03,\r\n        S4 = 0x04,\r\n        S5 = 0x05,\r\n        S6 = 0x06\r\n    }\r\n\r\n    export enum Motors {\r\n        Left = 0x1,\r\n        Right = 0x2,\r\n        Centre = 0x3\r\n    }\r\n\r\n    export enum Steppers {\r\n        M1 = 0x1,\r\n        M2 = 0x2\r\n    }\r\n\r\n    export enum Turns {\r\n        //% blockId=\"T1B4\" block=\"1/4\"\r\n        T1B4 = 90,\r\n        //% blockId=\"T1B2\" block=\"1/2\"\r\n        T1B2 = 180,\r\n        //% blockId=\"T1B0\" block=\"1\"\r\n        T1B0 = 360,\r\n        //% blockId=\"T2B0\" block=\"2\"\r\n        T2B0 = 720,\r\n        //% blockId=\"T3B0\" block=\"3\"\r\n        T3B0 = 1080,\r\n        //% blockId=\"T4B0\" block=\"4\"\r\n        T4B0 = 1440,\r\n        //% blockId=\"T5B0\" block=\"5\"\r\n        T5B0 = 1800\r\n    }\r\n    \r\n     export enum enObstacle {\r\n        //% blockId=\"Obstacle\" block=\"有障碍物\"\r\n        Obstacle = 0,\r\n        //% blockId=\"NoObstacle\" block=\"无障碍物\"\r\n        NoObstacle = 1\r\n    }\r\n\r\n     export enum enflame {\r\n        //% blockId=\"Flame\" block=\"发现火焰\"\r\n        Flame = 0,\r\n        //% blockId=\"NoFlame\" block=\"无火焰\"\r\n        NoFlame = 1\r\n    }\r\n\r\n    export enum PingUnit{\r\n        //% block=\"us\"\r\n        MicroSeconds,\r\n        //% block=\"cm\"\r\n        Centimeters,\r\n        //% block=\"inches\"\r\n        Inches\r\n    }\r\n\r\n    let initialized = false\r\n    let initializedMatrix = false\r\n    let neoStrip: neopixel.Strip;\r\n    let matBuf = pins.createBuffer(17);\r\n    let distanceBuf = 0;\r\n\r\n    function i2cwrite(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2ccmd(addr: number, value: number) {\r\n        let buf = pins.createBuffer(1)\r\n        buf[0] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    function initPCA9685(): void {\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\r\n        setFreq(50);\r\n        for (let idx = 0; idx < 16; idx++) {\r\n            setPwm(idx, 0 ,0);\r\n        }\r\n        initialized = true\r\n    }\r\n\r\n    function setFreq(freq: number): void {\r\n        // Constrain the frequency\r\n        let prescaleval = 25000000;\r\n        prescaleval /= 4096;\r\n        prescaleval /= freq;\r\n        prescaleval -= 1;\r\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\r\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\r\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\r\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\r\n        control.waitMicros(5000);\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\r\n    }\r\n\r\n    function setPwm(channel: number, on: number, off: number): void {\r\n        if (channel < 0 || channel > 15)\r\n            return;\r\n        //serial.writeValue(\"ch\", channel)\r\n        //serial.writeValue(\"on\", on)\r\n        //serial.writeValue(\"off\", off)\r\n        \r\n        let buf = pins.createBuffer(5);\r\n        buf[0] = LED0_ON_L + 4 * channel;\r\n        buf[1] = on & 0xff;\r\n        buf[2] = (on >> 8) & 0xff;\r\n        buf[3] = off & 0xff;\r\n        buf[4] = (off >> 8) & 0xff;\r\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\r\n    }\r\n\r\n    //% blockId=robotbit_setLeveL block=\"控制声音传感器|%index|电平 %value\"\r\n    //% weight=99\r\n    //% blockGap=50\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function setLevel(index: Servos, value: boolean): void { \r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        if (value == true) {\r\n            setPwm(index+7, 0, 4095);\r\n        }\r\n        else { \r\n            setPwm(index+7, 0, 0);\r\n        }\r\n    }\r\n\r\n    function setStepper(index: number, dir: boolean): void {\r\n        if (index == 1) {\r\n            if (dir) {\r\n                setPwm(0, STP_CHA_L, STP_CHA_H);\r\n                setPwm(2, STP_CHB_L, STP_CHB_H);\r\n                setPwm(1, STP_CHC_L, STP_CHC_H);\r\n                setPwm(3, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(3, STP_CHA_L, STP_CHA_H);\r\n                setPwm(1, STP_CHB_L, STP_CHB_H);\r\n                setPwm(2, STP_CHC_L, STP_CHC_H);\r\n                setPwm(0, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        } else {\r\n            if (dir) {\r\n                setPwm(4, STP_CHA_L, STP_CHA_H);\r\n                setPwm(6, STP_CHB_L, STP_CHB_H);\r\n                setPwm(5, STP_CHC_L, STP_CHC_H);\r\n                setPwm(7, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(7, STP_CHA_L, STP_CHA_H);\r\n                setPwm(5, STP_CHB_L, STP_CHB_H);\r\n                setPwm(6, STP_CHC_L, STP_CHC_H);\r\n                setPwm(4, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopMotor(index: number) {\r\n        setPwm((index - 1) * 2, 0, 0);\r\n        setPwm((index - 1) * 2 + 1, 0, 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Init RGB pixels mounted on robotbit\r\n     */\r\n    //% blockId=\"robotbit_rgb\" block=\"RGB\"\r\n    //% weight=5\r\n    export function rgb(): neopixel.Strip {\r\n        if (!neoStrip) {\r\n            neoStrip = neopixel.create(DigitalPin.P16, 4, NeoPixelMode.RGB)\r\n        }\r\n\r\n        return neoStrip;\r\n    }\r\n\r\n    /**\r\n     * Servo Execute\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\r\n    */\r\n    //% blockId=robotbit_servo block=\"舵机|%index|角度 %degree\"\r\n    //% weight=100\r\n    //% degree.min=0 degree.max=180\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function Servo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n     * Geek Servo\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [-45-225] degree of servo; eg: -45, 90, 225\r\n    */\r\n    //% blockId=robotbit_gservo block=\"Geek Servo|%index|角度 %degree\"\r\n    //% weight=99\r\n    //% blockGap=50\r\n    //% degree.min=-45 degree.max=225\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function GeekServo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = ((degree -90) * 20 / 3 + 1500) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n    \r\n    //% blockId=robotbit_motor_run block=\"电机|%index|速度 %speed\"\r\n    //% weight=85\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRun(index: Motors, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        speed = speed * 16; // map 255 to 4096\r\n        if (speed >= 4096) {\r\n            speed = 4095\r\n        }\r\n        if (speed <= -4096) {\r\n            speed = -4095\r\n        }\r\n        if (index > 4 || index <= 0)\r\n            return\r\n        let pp = (index - 1) * 2\r\n        let pn = (index - 1) * 2 + 1\r\n        if (speed >= 0) {\r\n            setPwm(pp, 0, speed)\r\n            setPwm(pn, 0, 0)\r\n        } else {\r\n            setPwm(pp, 0, 0)\r\n            setPwm(pn, 0, -speed)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute two motors at the same time\r\n     * @param motor1 First Motor; eg: M1A, M1B\r\n     * @param speed1 [-255-255] speed of motor; eg: 150, -150\r\n     * @param motor2 Second Motor; eg: M2A, M2B\r\n     * @param speed2 [-255-255] speed of motor; eg: 150, -150\r\n    */\r\n    //% blockId=robotbit_motor_dual block=\"电机|%motor1|速度 %speed1|%motor2|速度 %speed2\"\r\n    //% weight=84\r\n    //% speed1.min=-255 speed1.max=255\r\n    //% speed2.min=-255 speed2.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\r\n        MotorRun(motor1, speed1);\r\n        MotorRun(motor2, speed2);\r\n    }\r\n\r\n    /**\r\n     * Execute single motors with delay\r\n     * @param index Motor Index; eg: M1A, M1B, M2A, M2B\r\n     * @param speed [-255-255] speed of motor; eg: 150, -150\r\n     * @param delay seconde delay to stop; eg: 1\r\n    */\r\n    //% blockId=robotbit_motor_rundelay block=\"电机|%index|速度 %speed|延时 %delay|s\"\r\n    //% weight=81\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\r\n        MotorRun(index, speed);\r\n        basic.pause(delay * 1000);\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=robotbit_stop block=\"停止电机|%index|\"\r\n    //% weight=80\r\n    export function MotorStop(index: Motors): void {\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=robotbit_stop_all block=\"停止所有电机\"\r\n    //% weight=79\r\n    //% blockGap=50\r\n    export function MotorStopAll(): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let idx = 1; idx <= 4; idx++) {\r\n            stopMotor(idx);\r\n        }\r\n    }\r\n    \r\n    //% blockId=Microbit_Sensor_IR block=\"红外避障传感器|引脚 %pin|值 %value\"\r\n    //% weight=96\r\n    //% blockGap=20\r\n    //% color=\"#228B22\"\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\r\n    export function IR(pin: DigitalPin, value: enObstacle): boolean {\r\n        pins.setPull(pin, PinPullMode.PullUp);\r\n        return pins.digitalReadPin(pin) == value;\r\n    }\r\n\r\n    //% blockId=Microbit_Sensor_flame block=\"火焰传感器|引脚 %pin|值 %value\"\r\n    //% weight=97\r\n    //% blockGap=20\r\n    //% color=\"#228B22\"\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\r\n    export function flame(pin: DigitalPin, value: enflame): boolean {\r\n        pins.setPull(pin, PinPullMode.PullUp);\r\n        return pins.digitalReadPin(pin) == value;\r\n    }  \r\n    \r\n    //% blockId=Microbit_ping block=\"超声波模块|echo %echo|unit %unit\"\r\n    export function ping(echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {\r\n        \r\n        setLevel(Servos.S3, false);\r\n        setLevel(Servos.S3, true);\r\n        setLevel(Servos.S3, false);\r\n        \r\n        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);\r\n\r\n        switch (unit) {\r\n            case PingUnit.Centimeters: return Math.idiv(d, 58);\r\n            case PingUnit.Inches: return Math.idiv(d, 148);\r\n            default: return d;\r\n        }      \r\n    }\r\n}\r\n","pxt.json":"{\n    \"name\": \"makebit\",\n    \"version\": \"3.0\",\n    \"description\": \"Extension for clb Robots micro:bit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.6.9\",\n        \"TM1650\": \"github:zhuning239/TM1650\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"branch\": \"v5.0.12\",\n        \"tag\": \"v5.0.12\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/97491d6832cccab6b5bdc05b58e4c6b5dcc18cdd\",\n        \"target\": \"5.0.12\",\n        \"pxt\": \"8.0.7\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as a library\r\n"}